# Основы синтаксиса

OneScript реализует спецификацию языка 1С (BSL) в версии для 1С:Предприятие 8. Данная документация не ставит себе целью полностью повторить описание языка, которое предоставляет фирма 1С. Для полного руководства по языку обратитесь к документации 1С.

Тем не менее, все больше пользователей начинают использовать 1Скрипт, не будучи знакомыми с 1С. Для них краткий ввод в синтаксис языка.

## Структура модуля

Единицей структурирования является `модуль`. Модуль это текстовый файл с расширением `.os` Каждый модуль может содержать 3 секции:

* \[Секция переменных\]
* \[Секция методов\]
* \[Секция тела модуля\]

В самом простейшем случае минимальный скрипт выглядит следующим образом:

```bsl
Сообщить("Привет, Мир!");
```

В примере выше модуль содержит только секцию тела модуля. Тело модуля это код, который начинает выполняться сразу при запуске. Тело модуля обязательно находится в самом низу файла. Обычно в теле модуля размещают код инициализации.

### Секция переменных

В самом верху модуля размещаются переменные уровня модуля целиком. Объявляются с помощью ключевого слова `Перем`

```bsl
// Секция переменных
Перем МояПеременная; // объявление переменной МояПеременная

// Секция тела модуля
МояПеременная = "Привет"; // инициализация переменной МояПеременная
```

### Секция методов

Секция методов находится между секцией переменных и телом модуля. Видов методов два: процедуры и функции. Функции могут возвращать результат своей работы в виде значения. Процедуры просто выполняют некий код и не возвращают результат.

Метод (процедура или функция) объявляется вот так:

```bsl
Процедура МояПроцедура(ВходнойПараметр1, ВходнойПараметр2)
    // Тут идут операторы процедуры
КонецПроцедуры

Функция МояФункция(ВходнойПараметр1, ВходнойПараметр2)
    // Тут идут операторы процедуры
    Возврат ВходнойПараметр1 + ВходнойПараметр2; // возврат результата функции
КонецФункции
```

## Типизация

Типизация динамическая нестрогая. Переменная может принимать любое значение. Есть примитивные типы: Строка, Число, Булево, Дата и есть объектные, к которым мы обращаемся через точку от экземпляра объекта.

Также есть специальные типы-значения Неопределено и Null. Они обозначают отсутствие значения.

## Литералы

### Число
Литерал числа это цифры, с возможной десятичной точкой: `12345.899`. Максимальная точность ограничена типом decimal платформы .NET

### Строка

Литерал строки это любая последовательность внутри двойных кавычек. Экранирование кавычки внутри строки выполняется удваиванием символа кавычки.

```bsl
"Это Строка"
"А это строка с неким названием ""Название"". Чтобы вывести кавычку нужно продублировать ее. На печать будет выведена одна кавычка"

"Многострочные строки оформляются переносом
|текста на следующую строку и выделением новой строки с 
|помощью вертикальной черты.
    |   Пробельные символы до этой черты - игнорируются. После - сохраняются"

```

### Дата

Даты оформляются одинарными кавычками и задаются в формате 'ГГГГММДДччммсс'. Например, 

```bsl
ДатаЗаданнаяЛитералом = '20250212235959'; // 12.02.2025 23:59:59
ДопускаютсяРазделители = '2025-02-12 23:59:59'; // 12.02.2025 23:59:59
```

## Блоки кода

### Условия

```bsl
Если ЛогическоеВыражение Тогда
    // тело операции, когда ЛогическоеВыражение равно Истина
ИначеЕсли ДругоеЛогическоеВыражение Тогда
    // альтернативное условие
Иначе
    // альтернативная ветка, когда все условия оказались ложными
КонецЕсли;
```

### Циклы

Обычный цикл со счетчиком. Объявляется переменная, задается ее начальное и конечное значение

```bsl
Для Счетчик = 0 По 10 Цикл
    Сообщить("Счетчик = " + Счетчик);
КонецЦикла;
```

Цикл-итератор по объекту коллекции

```bsl
НекийМассив = Новый Массив;
Массив.Добавить(1);
Массив.Добавить(2);
Массив.Добавить(3);

Для Каждого Элемент Из Массив Цикл
    Сообщить("Элемент = " + Элемент);
КонецЦикла;
```

Цикл с предусловием

```bsl
Пока ЛогическоеУсловие Цикл
    // Исполняется пока ЛогическоеУсловие = Истина
КонецЦикла;
```

## Обработка исключений

Отлов исключений выполняется конструкцией Попытка..Исключение. Исключения нетипизированные, любое выбрасываемое из пользовательского кода значение приводится к строке. 

В отличие от 1С есть возможность выброса исключения с дополнительной информацией, см. про это в разделе ["Отличия от 1С"](./#differences).

```bsl
Попытка
    А = 2 / 0;
Исключение

    Сообщить(ОписаниеОшибки());
    Сообщить(ИнформацияОбОшибке().НомерСтроки);
    Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

    ВызватьИсключение; // повторный выброс пойманного исключения (rethrow)

КонецПопытки;
```

Генерация исключений вызывается оператором `ВызватьИсключение`

```bsl
ВызватьИсключение "Это моя собственная ошибка, которую я хочу выбросить";
```

## Отличия от 1С {#differences}

* Не поддерживается оператор `Перейти` и метки
* Функции `ДобавитьОбработчик`, `УдалитьОбработчик` не поддерживают события COM-объектов.
* Добавлена нестандартная директива препроцессора `#Использовать`, предназначенная для подключения внешних библиотек.
* Не используется механика "подсчета ссылок", принятая в 1С. Вместо этого применяется штатный сборщик мусора .NET. Это порождает непривычные специалисту 1С эффекты недетерминированного уничтожения объектов. Для явной очистки объектов введены функции:
    * ОсвободитьОбъект()
    * ВыполнитьСборкуМусора()
* Отличается внутренняя реализация типа Число. В 1Script используется тип .NET System.Decimal, который имеет меньшую размерность, чем тип числа в 1С.
* Есть возможность создавать собственные обходимые типы и параметризованные конструкторы классов. См. раздел ["Расширенные возможности"](/learn/advanced-usage)

### Отличия в функции Формат

Для параметра `ДФ` добавлен формат `р` (кириллица) или `f` для отображения дробных частей секунды.

```bsl
Строка = Формат(Дата, "ДФ=ЧЧ:мм:сс.ррр");
// Строка = "20:02:53.345"
```

Допускается указывать до 6 разрядов дробной части.

### Отличия в вызове конструктора

В 1Скрипт разрешается обращаться к результату вызова конструктора сразу же через точку в том же операторе. Т.е. вызов конструктора является полноценным выражением. В 1С такое запрещено.

```bsl
Если Новый Файл("myfile.txt").Существует() Тогда
    // файл сконструирован и сразу же мы обращаемся к методу Существует()
КонецЕсли;
```

### Параметризованные исключения

Существует возможность выброса параметризованных исключений, а не только строк. В 1Скрипт объект `ИнформацияОбОшибке` имеет конструктор, в котором можно указать дополнительные параметры исключения.

```bsl
ВызватьИсключение Новый ИнформацияОбОшибке("Текст ошибки", ДополнительныеДанные);
```

При перехвате такого исключения в `ИнформацияОбОшибке` будет заполнено свойство `Параметры`, и оно будет иметь то значение, которое было передано в конструктор исключения при генерации исключения.

### rethrow имеющегося исключения

Обычно, для перевыброса исключения в 1С мы вызываем оператор `ВызватьИсключение` без параметров. Это не создает новое исключение, а перевыбрасывает старое и позволяет сохранить стек исключения и обработать его дальше.

В 1Скрипт есть расширение этого поведения. Если у нас имеется уже значение типа `ИнформацияОбОшибке`, например, полученная из фонового задания, то мы тоже можем сделать генерацию исключения, у которого в свойстве "Причина" будет находиться оригинальное исключение. Для этого, ИнформацияОбОшибке может быть указана в качестве аргумента оператора `ВызватьИсключение`

```bsl
ОшибкаВЗадании = МоеФоновоеЗадание.ИнформацияОбОшибке;
Если ОшибкаВЗадании <> Неопределено Тогда
    ВызватьИсключение ОшибкаВЗадании; // Здесь выбрасывается исключение, у которого свойство Причина равно ОшибкаВЗадании.
КонецЕсли;
```